import collections as _abc
from typing import Any, Optional, Mapping, TypeVar, Iterable, NewType, Iterator, Union, Callable, Tuple, List

__author__: str
__copyright__: Any

class ShortKeyError(KeyError): ...


Step = TypeVar('Step')
V = TypeVar('V')
UserKey = NewType('UserKey', Iterable[Step])
InternalKey = NewType('InternalKey', Iterable[Step])
Path = NewType('Path', List[Step])
#Path = List[Step]
Trace = List[Tuple[Step, '_Node']]
ChildTypes = Union['_NoChildren', '_OneChild', '_Children']

TraversalResult = TypeVar('TraversalResult')

NodeFactory = Callable[
    [
        Callable[[Path], InternalKey], # path_conv
        Path, # path
        Iterable[TraversalResult], #children
        Optional[V] #value
    ],
    TraversalResult]

class _NoChildren:
    __slots__: Any = ...
    def __bool__(self): ...
    __nonzero__: Any = ...
    def __len__(self): ...
    def __iter__(self) -> Any: ...
    iteritems: Any = ...
    def __next__(self) -> None: ...
    next: Any = ...
    def get(self, _step: Step) -> None: ...
    def add(self, parent: Any, step: Step): ...
    require: Any = ...
    def copy(self, _make_copy: Any, _queue: Any): ...
    def __deepcopy__(self, memo: Any): ...

_EMPTY: _NoChildren

class _OneChild:
    __solts__: Any = ...
    step: Step = ...
    node: _Node = ...
    def __init__(self, step: Any, node: Any) -> None: ...
    def __bool__(self): ...
    __nonzero__: Any = ...
    def __len__(self): ...
    def sorted_items(self) -> Trace: ...
    def iteritems(self) -> Trace: ...
    def get(self, step: Step) -> _Node: ...
    def add(self, parent: _Node, step: Step) -> _Node: ...
    def require(self, parent: _Node, step: Step): ...
    def delete(self, parent: _Node, _step: Step) -> None: ...
    def pick_child(self) -> Tuple[Step, _Node]: ...
    def copy(self, make_copy: Any, queue: Any): ...

class _Children(dict):
    __slots__: Any = ...
    def __init__(self, *items: Any) -> None: ...
    def sorted_items(self): ...
    def iteritems(self): ...
    def add(self, _parent: Any, step: Any): ...
    def require(self, _parent: Any, step: Any): ...
    def delete(self, parent: Any, step: Any) -> None: ...
    def pick_child(self): ...
    def copy(self, make_copy: Any, queue: Any): ...

class _Node:
    __slots__: Any = ...
    children: ChildTypes = ...
    value: V = ...
    def __init__(self) -> None: ...
    def iterate(self, path: Any, shallow: Any, iteritems: Any) -> None: ...
    def traverse(self,
                 node_factory: NodeFactory,
                 path_conv: Callable[[Path], InternalKey],
                 path: Path,
                 iteritems: Callable[[ChildTypes], Iterable[Tuple[Step, _Node]]]): ...
    def equals(self, other: Any): ...
    __bool__: Any = ...
    __nonzero__: Any = ...
    __hash__: Any = ...
    def shallow_copy(self, make_copy: Any): ...
    def copy(self, make_copy: Any): ...
    def __getstate__(self): ...
    def __setstate__(self, state: Any) -> None: ...


class Trie(_abc.MutableMapping, Mapping[UserKey, V]):
    _root: _Node = ...
    _sorted: bool = ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    @property
    def _iteritems(self) -> Callable[[ChildTypes], Iterable[Tuple[Step, _Node]]]: ...
    def enable_sorting(self, enable: bool = ...) -> None: ...
    def clear(self) -> None: ...
    def update(self, *args: Any, **kwargs: Any) -> None: ...
    def copy(self, __make_copy: Any = ...): ...
    def __copy__(self): ...
    def __deepcopy__(self, memo: Any): ...
    @classmethod
    def fromkeys(cls, keys: Any, value: Optional[Any] = ...): ...
    def _get_node(self, key: UserKey) -> Tuple[_Node, Trace]: ...
    def _set_node(self, key: Any, value: Any, only_if_missing: bool = ...): ...
    def _set_node_if_no_prefix(self, key: Any) -> None: ...
    def __iter__(self) -> Any: ...
    def iteritems(self, prefix: Any = ..., shallow: bool = ...) -> Iterator[Tuple[UserKey, V]]: ...
    def iterkeys(self, prefix: Any = ..., shallow: bool = ...) -> None: ...
    def itervalues(self, prefix: Any = ..., shallow: bool = ...) -> None: ...
    def items(self, prefix: Any = ..., shallow: bool = ...): ...
    def keys(self, prefix: Any = ..., shallow: bool = ...): ...
    def values(self, prefix: Any = ..., shallow: bool = ...): ...
    def __len__(self): ...
    def __bool__(self): ...
    __nonzero__: Any = ...
    __hash__: Any = ...
    HAS_VALUE: int = ...
    HAS_SUBTRIE: int = ...
    def has_node(self, key: UserKey): ...
    def has_key(self, key: UserKey): ...
    def has_subtrie(self, key: UserKey): ...
    @staticmethod
    def _slice_maybe(key_or_slice: Any): ...
    def __getitem__(self, key_or_slice: Any): ...
    def __setitem__(self, key_or_slice: Any, value: Any) -> None: ...
    def setdefault(self, key: Any, value: Optional[Any] = ...): ...
    @staticmethod
    def _cleanup_trace(trace: Any) -> None: ...
    def _pop_from_node(self, node: Any, trace: Any): ...
    def pop(self, key: UserKey, default: Any = ...): ...
    def popitem(self): ...
    def __delitem__(self, key_or_slice: Any) -> None: ...
    class _NoneStep:
        __slots__: Any = ...
        def __bool__(self): ...
        __nonzero__: Any = ...
        def get(self, default: Optional[Any] = ...): ...
        is_set: Any = ...
        has_subtrie: Any = ...
        key: Any = ...
        value: Any = ...
        def __getitem__(self, index: Any): ...
        def __repr__(self): ...
    class _Step(_NoneStep):
        __slots__: Any = ...
        _trie: Any = ...
        _path: Any = ...
        _pos: Any = ...
        _node: Any = ...
        def __init__(self, trie: Any, path: Any, pos: Any, node: Any) -> None: ...
        def __bool__(self): ...
        __nonzero__: Any = ...
        @property
        def is_set(self): ...
        @property
        def has_subtrie(self): ...
        def get(self, default: Optional[Any] = ...): ...
        def set(self, value: Any) -> None: ...
        def setdefault(self, value: Any): ...
        def __repr__(self): ...
        __key: Any = ...
        @property
        def key(self): ...
        @property
        def value(self): ...
    _NONE_STEP: Any = ...
    def walk_towards(self, key: UserKey) -> Iterator[Trie._Step]: ...
    def prefixes(self, key: UserKey) -> Iterator[Trie._Step]: ...
    def shortest_prefix(self, key: UserKey) -> Union[Trie._Step, Trie._NoneStep]: ...
    def longest_prefix(self, key: UserKey) -> Union[Trie._Step, Trie._NoneStep]: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def _str_items(self, fmt: str = ...): ...
    def __path_from_key(self, key: UserKey) -> Path: ...
    def _path_from_key(self, key: UserKey) -> Path: ...
    def _key_from_path(self, path: Path) -> InternalKey: ...
    def traverse(self,
                 node_factory: Any,
                 prefix: Any = ...): ...

class CharTrie(Trie):
    def _key_from_path(self, path: Any): ...

class StringTrie(Trie):
    _separator: Any = ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    @classmethod
    def fromkeys(cls, keys: Any, value: Optional[Any] = ..., separator: str = ...): ...
    def __str__(self): ...
    def __repr__(self): ...
    def _path_from_key(self, key: Any): ...
    def _key_from_path(self, path: Any): ...

class PrefixSet(_abc.MutableSet):
    _trie: Any = ...
    def __init__(self, iterable: Any = ..., factory: Any = ..., **kwargs: Any) -> None: ...
    def copy(self): ...
    def __copy__(self): ...
    def __deepcopy__(self, memo: Any): ...
    def clear(self) -> None: ...
    def __contains__(self, key: Any): ...
    def __iter__(self) -> Any: ...
    def iter(self, prefix: Any = ...): ...
    def __len__(self): ...
    def add(self, value: Any) -> None: ...
    def discard(self, value: Any) -> None: ...
    def remove(self, value: Any) -> None: ...
    def pop(self) -> None: ...
